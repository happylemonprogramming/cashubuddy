"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const he=require("@cashu/crypto/modules/client/NUT12"),D=require("@cashu/crypto/modules/common"),_=require("@noble/curves/abstract/utils"),Ie=require("@noble/hashes/sha256"),Q=require("buffer"),M=require("@cashu/crypto/modules/client"),se=require("@cashu/crypto/modules/client/NUT11"),v=require("@noble/hashes/utils"),ne=require("@cashu/crypto/modules/client/NUT09");function Ae(s){return Q.Buffer.from(s).toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function de(s){return Q.Buffer.from(s,"base64")}function Te(s){const e=JSON.stringify(s);return De(Q.Buffer.from(e).toString("base64"))}function ve(s){const e=Q.Buffer.from(xe(s),"base64").toString();return JSON.parse(e)}function xe(s){return s.replace(/-/g,"+").replace(/_/g,"/").split("=")[0]}function De(s){return s.replace(/\+/g,"-").replace(/\//g,"_").split("=")[0]}function Ue(s){return typeof s=="number"||typeof s=="string"}function $(s){const e=[];return V(s,e),new Uint8Array(e)}function V(s,e){if(s===null)e.push(246);else if(s===void 0)e.push(247);else if(typeof s=="boolean")e.push(s?245:244);else if(typeof s=="number")le(s,e);else if(typeof s=="string")fe(s,e);else if(Array.isArray(s))Me(s,e);else if(s instanceof Uint8Array)Be(s,e);else if(typeof s=="object")Fe(s,e);else throw new Error("Unsupported type")}function le(s,e){if(s<24)e.push(s);else if(s<256)e.push(24,s);else if(s<65536)e.push(25,s>>8,s&255);else if(s<4294967296)e.push(26,s>>24,s>>16&255,s>>8&255,s&255);else throw new Error("Unsupported integer size")}function Be(s,e){const t=s.length;if(t<24)e.push(64+t);else if(t<256)e.push(88,t);else if(t<65536)e.push(89,t>>8&255,t&255);else if(t<4294967296)e.push(90,t>>24&255,t>>16&255,t>>8&255,t&255);else throw new Error("Byte string too long to encode");for(let n=0;n<s.length;n++)e.push(s[n])}function fe(s,e){const t=new TextEncoder().encode(s),n=t.length;if(n<24)e.push(96+n);else if(n<256)e.push(120,n);else if(n<65536)e.push(121,n>>8&255,n&255);else if(n<4294967296)e.push(122,n>>24&255,n>>16&255,n>>8&255,n&255);else throw new Error("String too long to encode");for(let r=0;r<t.length;r++)e.push(t[r])}function Me(s,e){const t=s.length;if(t<24)e.push(128|t);else if(t<256)e.push(152,t);else if(t<65536)e.push(153,t>>8,t&255);else throw new Error("Unsupported array length");for(const n of s)V(n,e)}function Fe(s,e){const t=Object.keys(s);le(t.length,e),e[e.length-1]|=160;for(const n of t)fe(n,e),V(s[n],e)}function G(s){const e=new DataView(s.buffer,s.byteOffset,s.byteLength);return W(e,0).value}function W(s,e){if(e>=s.byteLength)throw new Error("Unexpected end of data");const t=s.getUint8(e++),n=t>>5,r=t&31;switch(n){case 0:return Ne(s,e,r);case 1:return Ke(s,e,r);case 2:return Oe(s,e,r);case 3:return Re(s,e,r);case 4:return Qe(s,e,r);case 5:return Le(s,e,r);case 7:return He(s,e,r);default:throw new Error(`Unsupported major type: ${n}`)}}function K(s,e,t){if(t<24)return{value:t,offset:e};if(t===24)return{value:s.getUint8(e++),offset:e};if(t===25){const n=s.getUint16(e,!1);return e+=2,{value:n,offset:e}}if(t===26){const n=s.getUint32(e,!1);return e+=4,{value:n,offset:e}}if(t===27){const n=s.getUint32(e,!1),r=s.getUint32(e+4,!1);return e+=8,{value:n*2**32+r,offset:e}}throw new Error(`Unsupported length: ${t}`)}function Ne(s,e,t){const{value:n,offset:r}=K(s,e,t);return{value:n,offset:r}}function Ke(s,e,t){const{value:n,offset:r}=K(s,e,t);return{value:-1-n,offset:r}}function Oe(s,e,t){const{value:n,offset:r}=K(s,e,t);if(r+n>s.byteLength)throw new Error("Byte string length exceeds data length");return{value:new Uint8Array(s.buffer,s.byteOffset+r,n),offset:r+n}}function Re(s,e,t){const{value:n,offset:r}=K(s,e,t);if(r+n>s.byteLength)throw new Error("String length exceeds data length");const o=new Uint8Array(s.buffer,s.byteOffset+r,n);return{value:new TextDecoder().decode(o),offset:r+n}}function Qe(s,e,t){const{value:n,offset:r}=K(s,e,t),o=[];let i=r;for(let c=0;c<n;c++){const a=W(s,i);o.push(a.value),i=a.offset}return{value:o,offset:i}}function Le(s,e,t){const{value:n,offset:r}=K(s,e,t),o={};let i=r;for(let c=0;c<n;c++){const a=W(s,i);if(!Ue(a.value))throw new Error("Invalid key type");const h=W(s,a.offset);o[a.value]=h.value,i=h.offset}return{value:o,offset:i}}function We(s){const e=(s&31744)>>10,t=s&1023,n=s&32768?-1:1;return e===0?n*2**-14*(t/1024):e===31?t?NaN:n*(1/0):n*2**(e-15)*(1+t/1024)}function He(s,e,t){if(t<24)switch(t){case 20:return{value:!1,offset:e};case 21:return{value:!0,offset:e};case 22:return{value:null,offset:e};case 23:return{value:void 0,offset:e};default:throw new Error(`Unknown simple value: ${t}`)}if(t===24)return{value:s.getUint8(e++),offset:e};if(t===25){const n=We(s.getUint16(e,!1));return e+=2,{value:n,offset:e}}if(t===26){const n=s.getFloat32(e,!1);return e+=4,{value:n,offset:e}}if(t===27){const n=s.getFloat64(e,!1);return e+=8,{value:n,offset:e}}throw new Error(`Unknown simple or float value: ${t}`)}class H{constructor(e,t,n,r,o,i,c=!1){this.transport=e,this.id=t,this.amount=n,this.unit=r,this.mints=o,this.description=i,this.singleUse=c}toEncodedRequest(){const e={t:this.transport.map(r=>({t:r.type,a:r.target,g:r.tags}))};this.id&&(e.i=this.id),this.amount&&(e.a=this.amount),this.unit&&(e.u=this.unit),this.mints&&(e.m=this.mints),this.description&&(e.d=this.description),this.singleUse&&(e.s=this.singleUse);const t=$(e);return"creqA"+Q.Buffer.from(t).toString("base64")}getTransport(e){return this.transport.find(t=>t.type===e)}static fromEncodedRequest(e){if(!e.startsWith("creq"))throw new Error("unsupported pr: invalid prefix");if(e[4]!=="A")throw new Error("unsupported pr version");const n=e.slice(5),r=de(n),o=G(r),i=o.t.map(c=>({type:c.t,target:c.a,tags:c.g}));return new H(i,o.i,o.a,o.u,o.m,o.d,o.s)}}const je="A",Ce="cashu";function S(s,e,t,n){if(t){const o=ie(t);if(o>s)throw new Error(`Split is greater than total amount: ${o} > ${s}`);if(t.some(i=>!me(i,e)))throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");s=s-ie(t)}else t=[];return pe(e,"desc").forEach(o=>{const i=Math.floor(s/o);for(let c=0;c<i;++c)t?.push(o);s%=o}),t.sort((o,i)=>o-i)}function re(s,e,t,n){const r=[],o=s.map(h=>h.amount);pe(t,"asc").forEach(h=>{const d=o.filter(m=>m===h).length,u=Math.max(n-d,0);for(let m=0;m<u&&!(r.reduce((l,f)=>l+f,0)+h>e);++m)r.push(h)});const c=e-r.reduce((h,d)=>h+d,0);return c&&S(c,t).forEach(d=>{r.push(d)}),r.sort((h,d)=>h-d)}function pe(s,e="desc"){return e=="desc"?Object.keys(s).map(t=>parseInt(t)).sort((t,n)=>n-t):Object.keys(s).map(t=>parseInt(t)).sort((t,n)=>t-n)}function me(s,e){return s in e}function ze(s){return ye(_.bytesToHex(s))}function ye(s){return BigInt(`0x${s}`)}function $e(s){return s.toString(16).padStart(64,"0")}function oe(s){return/^[a-f0-9]*$/i.test(s)}function ge(s){return Array.isArray(s)?s.some(e=>!oe(e.id)):oe(s.id)}function Ve(s){const e={token:[{mint:s.mint,proofs:s.proofs}]};return s.unit&&(e.unit=s.unit),s.memo&&(e.memo=s.memo),Ce+je+Te(e)}function Ge(s,e){if(ge(s.proofs)||e?.version===3){if(e?.version===4)throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");return Ve(s)}return we(s)}function we(s){if(s.proofs.forEach(c=>{if(c.dleq&&c.dleq.r==null)throw new Error("Missing blinding factor in included DLEQ proof")}),ge(s.proofs))throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");const t=ke(s),n=$(t),r="cashu",o="B",i=Ae(n);return r+o+i}function ke(s){const e={},t=s.mint;for(let r=0;r<s.proofs.length;r++){const o=s.proofs[r];e[o.id]?e[o.id].push(o):e[o.id]=[o]}const n={m:t,u:s.unit||"sat",t:Object.keys(e).map(r=>({i:_.hexToBytes(r),p:e[r].map(o=>({a:o.amount,s:o.secret,c:_.hexToBytes(o.C),...o.dleq&&{d:{e:_.hexToBytes(o.dleq.e),s:_.hexToBytes(o.dleq.s),r:_.hexToBytes(o.dleq.r??"00")}}}))}))};return s.memo&&(n.d=s.memo),n}function be(s){const e=[];s.t.forEach(n=>n.p.forEach(r=>{e.push({secret:r.s,C:_.bytesToHex(r.c),amount:r.a,id:_.bytesToHex(n.i),...r.d&&{dleq:{r:_.bytesToHex(r.d.r),s:_.bytesToHex(r.d.s),e:_.bytesToHex(r.d.e)}}})}));const t={mint:s.m,proofs:e,unit:s.u||"sat"};return s.d&&(t.memo=s.d),t}function _e(s){return["web+cashu://","cashu://","cashu:","cashu"].forEach(t=>{s.startsWith(t)&&(s=s.slice(t.length))}),Je(s)}function Je(s){const e=s.slice(0,1),t=s.slice(1);if(e==="A"){const n=ve(t);if(n.token.length>1)throw new Error("Multi entry token are not supported");const r=n.token[0],o={mint:r.mint,proofs:r.proofs,unit:n.unit||"sat"};return n.memo&&(o.memo=n.memo),o}else if(e==="B"){const n=de(t),r=G(n);return be(r)}throw new Error("Token version is not supported")}function Ye(s){const e=Object.entries(s).sort((r,o)=>+r[0]-+o[0]).map(([,r])=>_.hexToBytes(r)).reduce((r,o)=>Xe(r,o),new Uint8Array),t=Ie.sha256(e);return"00"+Buffer.from(t).toString("hex").slice(0,14)}function Xe(s,e){const t=new Uint8Array(s.length+e.length);return t.set(s),t.set(e,s.length),t}function x(s){return typeof s=="object"}function E(...s){return s.map(e=>e.replace(/(^\/+|\/+$)/g,"")).join("/")}function Ze(s){return s.replace(/\/$/,"")}function B(s){return s.reduce((e,t)=>e+t.amount,0)}function et(s){return H.fromEncodedRequest(s)}class tt{get value(){return this._value}set value(e){this._value=e}get next(){return this._next}set next(e){this._next=e}constructor(e){this._value=e,this._next=null}}class st{get first(){return this._first}set first(e){this._first=e}get last(){return this._last}set last(e){this._last=e}get size(){return this._size}set size(e){this._size=e}constructor(){this._first=null,this._last=null,this._size=0}enqueue(e){const t=new tt(e);return this._size===0||!this._last?(this._first=t,this._last=t):(this._last.next=t,this._last=t),this._size++,!0}dequeue(){if(this._size===0||!this._first)return null;const e=this._first;return this._first=e.next,e.next=null,this._size--,e.value}}function L(s){return s.map(e=>{const t={...e};return delete t.dleq,delete t.dleqValid,t})}function nt(s,e){if(s.dleq==null)return!1;const t={e:_.hexToBytes(s.dleq.e),s:_.hexToBytes(s.dleq.s),r:ye(s.dleq.r??"00")};if(!me(s.amount,e.keys))throw new Error(`undefined key for amount ${s.amount}`);const n=e.keys[s.amount];return!!he.verifyDLEQProof_reblind(new TextEncoder().encode(s.secret),t,D.pointFromHex(s.C),D.pointFromHex(n))}function rt(...s){const e=s.reduce((r,o)=>r+o.length,0),t=new Uint8Array(e);let n=0;for(let r=0;r<s.length;r++)t.set(s[r],n),n=n+s[r].length;return t}function ot(s){const e=new TextEncoder,t=ke(s),n=$(t),r=e.encode("craw"),o=e.encode("B");return rt(r,o,n)}function it(s){const e=new TextDecoder,t=e.decode(s.slice(0,4)),n=e.decode(new Uint8Array([s[4]]));if(t!=="craw"||n!=="B")throw new Error("not a valid binary token");const r=s.slice(5),o=G(r);return be(o)}function ie(s){return s.reduce((e,t)=>e+t,0)}let J;typeof WebSocket<"u"&&(J=WebSocket);function ct(s){J=s}function at(){return J}class N{constructor(){this.connectionMap=new Map}static getInstance(){return N.instace||(N.instace=new N),N.instace}getConnection(e){if(this.connectionMap.has(e))return this.connectionMap.get(e);const t=new ut(e);return this.connectionMap.set(e,t),t}}class ut{constructor(e){this.subListeners={},this.rpcListeners={},this.rpcId=0,this._WS=at(),this.url=new URL(e),this.messageQueue=new st}connect(){return this.connectionPromise||(this.connectionPromise=new Promise((e,t)=>{try{this.ws=new this._WS(this.url)}catch(n){t(n);return}this.ws.onopen=()=>{e()},this.ws.onerror=()=>{t(new Error("Failed to open WebSocket"))},this.ws.onmessage=n=>{this.messageQueue.enqueue(n.data),this.handlingInterval||(this.handlingInterval=setInterval(this.handleNextMesage.bind(this),0))},this.ws.onclose=()=>{this.connectionPromise=void 0}})),this.connectionPromise}sendRequest(e,t){if(this.ws?.readyState!==1)throw new Error("Socket not open...");const n=this.rpcId;this.rpcId++;const r=JSON.stringify({jsonrpc:"2.0",method:e,params:t,id:n});this.ws?.send(r)}closeSubscription(e){this.ws?.send(JSON.stringify(["CLOSE",e]))}addSubListener(e,t){(this.subListeners[e]=this.subListeners[e]||[]).push(t)}addRpcListener(e,t,n){this.rpcListeners[n]={callback:e,errorCallback:t}}removeRpcListener(e){delete this.rpcListeners[e]}removeListener(e,t){if(this.subListeners[e].length===1){delete this.subListeners[e];return}this.subListeners[e]=this.subListeners[e].filter(n=>n!==t)}async ensureConnection(){this.ws?.readyState!==1&&await this.connect()}handleNextMesage(){if(this.messageQueue.size===0){clearInterval(this.handlingInterval),this.handlingInterval=void 0;return}const e=this.messageQueue.dequeue();let t;try{if(t=JSON.parse(e),"result"in t&&t.id!=null)this.rpcListeners[t.id]&&(this.rpcListeners[t.id].callback(),this.removeRpcListener(t.id));else if("error"in t&&t.id!=null)this.rpcListeners[t.id]&&(this.rpcListeners[t.id].errorCallback(t.error),this.removeRpcListener(t.id));else if("method"in t&&!("id"in t)){const n=t.params.subId;if(!n)return;if(this.subListeners[n]?.length>0){const r=t;this.subListeners[n].forEach(o=>o(r.params.payload))}}}catch(n){console.error(n);return}}createSubscription(e,t,n){if(this.ws?.readyState!==1)return n(new Error("Socket is not open"));const r=(Math.random()+1).toString(36).substring(7);return this.addRpcListener(()=>{this.addSubListener(r,t)},o=>{n(new Error(o.message))},this.rpcId),this.sendRequest("subscribe",{...e,subId:r}),this.rpcId++,r}cancelSubscription(e,t){this.removeListener(e,t),this.rpcId++,this.sendRequest("unsubscribe",{subId:e})}get activeSubscriptions(){return Object.keys(this.subListeners)}close(){this.ws&&this.ws?.close()}}var Pe=(s=>(s.UNSPENT="UNSPENT",s.PENDING="PENDING",s.SPENT="SPENT",s))(Pe||{}),F=(s=>(s.UNPAID="UNPAID",s.PENDING="PENDING",s.PAID="PAID",s))(F||{}),R=(s=>(s.UNPAID="UNPAID",s.PAID="PAID",s.ISSUED="ISSUED",s))(R||{}),Ee=(s=>(s.POST="post",s.NOSTR="nostr",s))(Ee||{});class ce extends Error{constructor(e,t){super(e),this.status=t}}let Se={};function ht(s){Se=s}async function dt({endpoint:s,requestBody:e,headers:t,...n}){const r=e?JSON.stringify(e):void 0,o={Accept:"application/json, text/plain, */*",...r?{"Content-Type":"application/json"}:void 0,...t},i=await fetch(s,{body:r,headers:o,...n});if(!i.ok){const{error:c,detail:a}=await i.json().catch(()=>({error:"bad response"}));throw new ce(c||a||"bad response",i.status)}try{return await i.json()}catch(c){throw console.error("Failed to parse HTTP response",c),new ce("bad response",i.status)}}async function A(s){return await dt({...s,...Se})}function j(s){return s.state||(console.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"),typeof s.paid=="boolean"&&(s.state=s.paid?F.PAID:F.UNPAID)),s}function ae(s){return s.state||(console.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"),typeof s.paid=="boolean"&&(s.state=s.paid?R.PAID:R.UNPAID)),s}function lt(s){return Array.isArray(s?.contact)&&s?.contact.length>0&&(s.contact=s.contact.map(e=>Array.isArray(e)&&e.length===2&&typeof e[0]=="string"&&typeof e[1]=="string"?(console.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"),{method:e[0],info:e[1]}):e)),s}class b{constructor(e,t){this._mintUrl=e,this._customRequest=t,this._mintUrl=Ze(e),this._customRequest=t}get mintUrl(){return this._mintUrl}static async getInfo(e,t){const r=await(t||A)({endpoint:E(e,"/v1/info")});return lt(r)}async getInfo(){return b.getInfo(this._mintUrl,this._customRequest)}static async swap(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/swap"),method:"POST",requestBody:t});if(!x(o)||!Array.isArray(o?.signatures))throw new Error(o.detail??"bad response");return o}async swap(e){return b.swap(this._mintUrl,e,this._customRequest)}static async createMintQuote(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/mint/quote/bolt11"),method:"POST",requestBody:t});return ae(o)}async createMintQuote(e){return b.createMintQuote(this._mintUrl,e,this._customRequest)}static async checkMintQuote(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/mint/quote/bolt11",t),method:"GET"});return ae(o)}async checkMintQuote(e){return b.checkMintQuote(this._mintUrl,e,this._customRequest)}static async mint(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/mint/bolt11"),method:"POST",requestBody:t});if(!x(o)||!Array.isArray(o?.signatures))throw new Error("bad response");return o}async mint(e){return b.mint(this._mintUrl,e,this._customRequest)}static async createMeltQuote(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/melt/quote/bolt11"),method:"POST",requestBody:t}),i=j(o);if(!x(i)||typeof i?.amount!="number"||typeof i?.fee_reserve!="number"||typeof i?.quote!="string")throw new Error("bad response");return i}async createMeltQuote(e){return b.createMeltQuote(this._mintUrl,e,this._customRequest)}static async checkMeltQuote(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/melt/quote/bolt11",t),method:"GET"}),i=j(o);if(!x(i)||typeof i?.amount!="number"||typeof i?.fee_reserve!="number"||typeof i?.quote!="string"||typeof i?.state!="string"||!Object.values(F).includes(i.state))throw new Error("bad response");return i}async checkMeltQuote(e){return b.checkMeltQuote(this._mintUrl,e,this._customRequest)}static async melt(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/melt/bolt11"),method:"POST",requestBody:t}),i=j(o);if(!x(i)||typeof i?.state!="string"||!Object.values(F).includes(i.state))throw new Error("bad response");return i}async melt(e){return b.melt(this._mintUrl,e,this._customRequest)}static async check(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/checkstate"),method:"POST",requestBody:t});if(!x(o)||!Array.isArray(o?.states))throw new Error("bad response");return o}static async getKeys(e,t,n){t&&(t=t.replace(/\//g,"_").replace(/\+/g,"-"));const o=await(n||A)({endpoint:t?E(e,"/v1/keys",t):E(e,"/v1/keys")});if(!x(o)||!Array.isArray(o.keysets))throw new Error("bad response");return o}async getKeys(e,t){return await b.getKeys(t||this._mintUrl,e,this._customRequest)}static async getKeySets(e,t){return(t||A)({endpoint:E(e,"/v1/keysets")})}async getKeySets(){return b.getKeySets(this._mintUrl,this._customRequest)}async check(e){return b.check(this._mintUrl,e,this._customRequest)}static async restore(e,t,n){const o=await(n||A)({endpoint:E(e,"/v1/restore"),method:"POST",requestBody:t});if(!x(o)||!Array.isArray(o?.outputs)||!Array.isArray(o?.promises))throw new Error("bad response");return o}async restore(e){return b.restore(this._mintUrl,e,this._customRequest)}async connectWebSocket(){if(this.ws)await this.ws.ensureConnection();else{const e=new URL(this._mintUrl),t="v1/ws";e.pathname&&(e.pathname.endsWith("/")?e.pathname+=t:e.pathname+="/"+t),this.ws=N.getInstance().getConnection(`${e.protocol==="https:"?"wss":"ws"}://${e.host}${e.pathname}`);try{await this.ws.connect()}catch(n){throw console.log(n),new Error("Failed to connect to WebSocket...")}}}disconnectWebSocket(){this.ws&&this.ws.close()}get webSocketConnection(){return this.ws}}class ue{constructor(e){this._mintInfo=e}isSupported(e){switch(e){case 4:case 5:return this.checkMintMelt(e);case 7:case 8:case 9:case 10:case 11:case 12:case 14:return this.checkGenericNut(e);case 17:return this.checkNut17();case 15:return this.checkNut15();default:throw new Error("nut is not supported by cashu-ts")}}checkGenericNut(e){return this._mintInfo.nuts[e]?.supported?{supported:!0}:{supported:!1}}checkMintMelt(e){const t=this._mintInfo.nuts[e];return t&&t.methods.length>0&&!t.disabled?{disabled:!1,params:t.methods}:{disabled:!0,params:t.methods}}checkNut17(){return this._mintInfo.nuts[17]&&this._mintInfo.nuts[17].supported.length>0?{supported:!0,params:this._mintInfo.nuts[17].supported}:{supported:!1}}checkNut15(){return this._mintInfo.nuts[15]&&this._mintInfo.nuts[15].methods.length>0?{supported:!0,params:this._mintInfo.nuts[15].methods}:{supported:!1}}get contact(){return this._mintInfo.contact}get description(){return this._mintInfo.description}get description_long(){return this._mintInfo.description_long}get name(){return this._mintInfo.name}get pubkey(){return this._mintInfo.pubkey}get nuts(){return this._mintInfo.nuts}get version(){return this._mintInfo.version}get motd(){return this._mintInfo.motd}}class C{constructor(e,t,n){this.amount=e,this.B_=t,this.id=n}getSerializedBlindedMessage(){return{amount:this.amount,B_:this.B_.toHex(!0),id:this.id}}}function z(s){return typeof s=="function"}class T{constructor(e,t,n){this.secret=n,this.blindingFactor=t,this.blindedMessage=e}toProof(e,t){let n;e.dleq&&(n={s:v.hexToBytes(e.dleq.s),e:v.hexToBytes(e.dleq.e),r:this.blindingFactor});const r={id:e.id,amount:e.amount,C_:D.pointFromHex(e.C_),dleq:n},o=D.pointFromHex(t.keys[e.amount]),i=M.constructProofFromPromise(r,this.blindingFactor,this.secret,o);return{...M.serializeProof(i),...n&&{dleqValid:he.verifyDLEQProof_reblind(this.secret,n,i.C,o)},...n&&{dleq:{s:v.bytesToHex(n.s),e:v.bytesToHex(n.e),r:$e(n.r??BigInt(0))}}}}static createP2PKData(e,t,n,r){return S(t,n.keys,r).map(i=>this.createSingleP2PKData(e,i,n.id))}static createSingleP2PKData(e,t,n){const r=["P2PK",{nonce:v.bytesToHex(v.randomBytes(32)),data:e.pubkey,tags:[]}];e.locktime&&r[1].tags.push(["locktime",e.locktime]),e.refundKeys&&r[1].tags.push(["refund",e.refundKeys]);const o=JSON.stringify(r),i=new TextEncoder().encode(o),{r:c,B_:a}=M.blindMessage(i);return new T(new C(t,a,n).getSerializedBlindedMessage(),c,i)}static createRandomData(e,t,n){return S(e,t.keys,n).map(o=>this.createSingleRandomData(o,t.id))}static createSingleRandomData(e,t){const n=v.bytesToHex(v.randomBytes(32)),r=new TextEncoder().encode(n),{r:o,B_:i}=M.blindMessage(r);return new T(new C(e,i,t).getSerializedBlindedMessage(),o,r)}static createDeterministicData(e,t,n,r,o){return S(e,r.keys,o).map((c,a)=>this.createSingleDeterministicData(c,t,n+a,r.id))}static createSingleDeterministicData(e,t,n,r){const o=ne.deriveSecret(t,r,n),i=v.bytesToHex(o),c=new TextEncoder().encode(i),a=ze(ne.deriveBlindingFactor(t,r,n)),{r:h,B_:d}=M.blindMessage(c,a);return new T(new C(e,d,r).getSerializedBlindedMessage(),h,c)}}const ft=3,pt="sat";class mt{constructor(e,t){this._keys=new Map,this._keysets=[],this._seed=void 0,this._unit=pt,this._mintInfo=void 0,this._denominationTarget=ft,this.mint=e;let n=[];if(t?.keys&&!Array.isArray(t.keys)?n=[t.keys]:t?.keys&&Array.isArray(t?.keys)&&(n=t?.keys),n&&n.forEach(r=>this._keys.set(r.id,r)),t?.unit&&(this._unit=t?.unit),t?.keysets&&(this._keysets=t.keysets),t?.mintInfo&&(this._mintInfo=new ue(t.mintInfo)),t?.denominationTarget&&(this._denominationTarget=t.denominationTarget),t?.bip39seed){if(t.bip39seed instanceof Uint8Array){this._seed=t.bip39seed;return}throw new Error("bip39seed must be a valid UInt8Array")}t?.keepFactory&&(this._keepFactory=t.keepFactory)}get unit(){return this._unit}get keys(){return this._keys}get keysetId(){if(!this._keysetId)throw new Error("No keysetId set");return this._keysetId}set keysetId(e){this._keysetId=e}get keysets(){return this._keysets}get mintInfo(){if(!this._mintInfo)throw new Error("Mint info not loaded");return this._mintInfo}async getMintInfo(){const e=await this.mint.getInfo();return this._mintInfo=new ue(e),this._mintInfo}async loadMint(){await this.getMintInfo(),await this.getKeySets(),await this.getKeys()}getActiveKeyset(e){let t=e.filter(r=>r.active);t=t.filter(r=>r.id.startsWith("00"));const n=t.sort((r,o)=>(r.input_fee_ppk??0)-(o.input_fee_ppk??0))[0];if(!n)throw new Error("No active keyset found");return n}async getKeySets(){const t=(await this.mint.getKeySets()).keysets.filter(n=>n.unit===this._unit);return this._keysets=t,this._keysets}async getAllKeys(){const e=await this.mint.getKeys();return this._keys=new Map(e.keysets.map(t=>[t.id,t])),this.keysetId=this.getActiveKeyset(this._keysets).id,e.keysets}async getKeys(e,t){if((!(this._keysets.length>0)||t)&&await this.getKeySets(),e||(e=this.getActiveKeyset(this._keysets).id),!this._keysets.find(n=>n.id===e)&&(await this.getKeySets(),!this._keysets.find(n=>n.id===e)))throw new Error(`could not initialize keys. No keyset with id '${e}' found`);if(!this._keys.get(e)){const n=await this.mint.getKeys(e);this._keys.set(e,n.keysets[0])}return this.keysetId=e,this._keys.get(e)}async receive(e,t){const{requireDleq:n,keysetId:r,outputAmounts:o,counter:i,pubkey:c,privkey:a,outputData:h,p2pk:d}=t||{};typeof e=="string"&&(e=_e(e));const u=await this.getKeys(r);if(n&&e.proofs.some(w=>!nt(w,u)))throw new Error("Token contains proofs with invalid DLEQ");const m=B(e.proofs)-this.getFeesForProofs(e.proofs);let l;h?l={send:h}:this._keepFactory&&(l={send:this._keepFactory});const f=this.createSwapPayload(m,e.proofs,u,o,i,c,a,l,d),{signatures:y}=await this.mint.swap(f.payload),g=f.outputData.map((w,p)=>w.toProof(y[p],u)),q=[];return f.sortedIndices.forEach((w,p)=>{q[w]=g[p]}),q}async send(e,t,n){const{proofsWeHave:r,offline:o,includeFees:i,includeDleq:c,keysetId:a,outputAmounts:h,pubkey:d,privkey:u,outputData:m}=n||{};if(c&&(t=t.filter(g=>g.dleq!=null)),B(t)<e)throw new Error("Not enough funds available to send");const{keep:l,send:f}=this.selectProofsToSend(t,e,n?.includeFees),y=i?this.getFeesForProofs(f):0;if(!o&&(B(f)!=e+y||h||d||u||a||m)){const{keep:g,send:q}=this.selectProofsToSend(t,e,!0);r?.push(...g);const w=await this.swap(e,q,n);let{keep:p,send:P}=w;const U=w.serialized;return p=g.concat(p),c||(P=L(P)),{keep:p,send:P,serialized:U}}if(B(f)<e+y)throw new Error("Not enough funds available to send");return c?{keep:l,send:f}:{keep:l,send:L(f)}}selectProofsToSend(e,t,n){const r=e.sort((l,f)=>l.amount-f.amount),o=r.filter(l=>l.amount<=t).sort((l,f)=>f.amount-l.amount),c=r.filter(l=>l.amount>t).sort((l,f)=>l.amount-f.amount)[0];if(!o.length&&c)return{keep:e.filter(l=>l.secret!==c.secret),send:[c]};if(!o.length&&!c)return{keep:e,send:[]};let a=t,h=[o[0]];const d=[],u=n?this.getFeesForProofs(h):0;if(a-=h[0].amount-u/1e3,a>0){const{keep:l,send:f}=this.selectProofsToSend(o.slice(1),a,n);h.push(...f),d.push(...l)}const m=n?this.getFeesForProofs(h):0;return B(h)<t+m&&c&&(h=[c]),{keep:e.filter(l=>!h.includes(l)),send:h}}getFeesForProofs(e){if(!this._keysets.length)throw new Error("Could not calculate fees. No keysets found");return new Set(e.map(r=>r.id)).forEach(r=>{if(!this._keysets.find(o=>o.id===r))throw new Error(`Could not calculate fees. No keyset found with id: ${r}`)}),Math.floor(Math.max((e.reduce((r,o)=>r+(this._keysets.find(i=>i.id===o.id)?.input_fee_ppk||0),0)+999)/1e3,0))}getFeesForKeyset(e,t){return Math.floor(Math.max((e*(this._keysets.find(r=>r.id===t)?.input_fee_ppk||0)+999)/1e3,0))}async swap(e,t,n){let{outputAmounts:r}=n||{};const{includeFees:o,keysetId:i,counter:c,pubkey:a,privkey:h,proofsWeHave:d,outputData:u,p2pk:m}=n||{},l=await this.getKeys(i),f=t;let y=e;const g=B(t);let q=g-y-this.getFeesForProofs(f),w=r?.sendAmounts||S(y,l.keys);if(o){let k=this.getFeesForKeyset(w.length,l.id),I=S(k,l.keys);for(;this.getFeesForKeyset(w.concat(I).length,l.id)>k;)k++,I=S(k,l.keys);w=w.concat(I),y+=k,q-=k}let p;if(!r?.keepAmounts&&d)p=re(d,q,l.keys,this._denominationTarget);else if(r){if(r.keepAmounts?.reduce((k,I)=>k+I,0)!=q)throw new Error("Keep amounts do not match amount to keep");p=r.keepAmounts}if(y+this.getFeesForProofs(f)>g)throw console.error(`Not enough funds available (${g}) for swap amountToSend: ${y} + fee: ${this.getFeesForProofs(f)} | length: ${f.length}`),new Error("Not enough funds available for swap");if(y+this.getFeesForProofs(f)+q!=g)throw new Error("Amounts do not match for swap");r={keepAmounts:p,sendAmounts:w};const P=u?.keep||this._keepFactory,U=u?.send,O=this.createSwapPayload(y,f,l,r,c,a,h,{keep:P,send:U},m),{signatures:qe}=await this.mint.swap(O.payload),Y=O.outputData.map((k,I)=>k.toProof(qe[I],l)),X=[],Z=[],ee=Array(O.keepVector.length),te=Array(Y.length);return O.sortedIndices.forEach((k,I)=>{ee[k]=O.keepVector[I],te[k]=Y[I]}),te.forEach((k,I)=>{ee[I]?X.push(k):Z.push(k)}),{keep:X,send:Z}}async restore(e,t,n){const{keysetId:r}=n||{},o=await this.getKeys(r);if(!this._seed)throw new Error("CashuWallet must be initialized with a seed to use restore");const i=Array(t).fill(0),c=T.createDeterministicData(i.length,this._seed,e,o,i),{outputs:a,promises:h}=await this.mint.restore({outputs:c.map(u=>u.blindedMessage)}),d=[];for(let u=0;u<a.length;u++){const m=c.find(l=>l.blindedMessage.B_===a[u].B_);m&&(d[u]={signature:h[u],data:m})}return d.forEach(u=>u.data.blindedMessage.amount=u.signature.amount),{proofs:d.map(u=>u.data.toProof(u.signature,o))}}async createMintQuote(e,t){const n={unit:this._unit,amount:e,description:t};return await this.mint.createMintQuote(n)}async checkMintQuote(e){return await this.mint.checkMintQuote(e)}async mintProofs(e,t,n){let{outputAmounts:r}=n||{};const{counter:o,pubkey:i,p2pk:c,keysetId:a,proofsWeHave:h,outputData:d}=n||{},u=await this.getKeys(a);!r&&h&&(r={keepAmounts:re(h,e,u.keys,this._denominationTarget),sendAmounts:[]});let m=[];if(d)if(z(d)){const y=S(e,u.keys,r?.keepAmounts);for(let g=0;g<y.length;g++)m.push(d(y[g],u))}else m=d;else if(this._keepFactory){const y=S(e,u.keys,r?.keepAmounts);for(let g=0;g<y.length;g++)m.push(this._keepFactory(y[g],u))}else m=this.createOutputData(e,u,o,i,r?.keepAmounts,c);const l={outputs:m.map(y=>y.blindedMessage),quote:t},{signatures:f}=await this.mint.mint(l);return m.map((y,g)=>y.toProof(f[g],u))}async createMeltQuote(e){const t={unit:this._unit,request:e};return await this.mint.createMeltQuote(t)}async checkMeltQuote(e){return await this.mint.checkMeltQuote(e)}async meltProofs(e,t,n){const{keysetId:r,counter:o,privkey:i}=n||{},c=await this.getKeys(r),a=this.createBlankOutputs(B(t)-e.amount,c,o,this._keepFactory);i!=null&&(t=se.getSignedProofs(t.map(u=>({amount:u.amount,C:D.pointFromHex(u.C),id:u.id,secret:new TextEncoder().encode(u.secret)})),i).map(u=>M.serializeProof(u))),t=L(t);const h={quote:e.quote,inputs:t,outputs:a.map(u=>u.blindedMessage)},d=await this.mint.melt(h);return{quote:d,change:d.change?.map((u,m)=>a[m].toProof(u,c))??[]}}createSwapPayload(e,t,n,r,o,i,c,a,h){const d=t.reduce((p,P)=>p+P.amount,0);r&&r.sendAmounts&&!r.keepAmounts&&(r.keepAmounts=S(d-e-this.getFeesForProofs(t),n.keys));const u=d-e-this.getFeesForProofs(t);let m=[],l=[];if(a?.keep)if(z(a.keep)){const p=a.keep;S(u,n.keys).forEach(U=>{m.push(p(U,n))})}else m=a.keep;else m=this.createOutputData(u,n,o,i,r?.keepAmounts,h,this._keepFactory);if(a?.send)if(z(a.send)){const p=a.send;S(e,n.keys).forEach(U=>{l.push(p(U,n))})}else l=a.send;else l=this.createOutputData(e,n,o?o+m.length:void 0,i,r?.sendAmounts,h);c&&(t=se.getSignedProofs(t.map(p=>({amount:p.amount,C:D.pointFromHex(p.C),id:p.id,secret:new TextEncoder().encode(p.secret)})),c).map(p=>M.serializeProof(p))),t=L(t);const f=[...m,...l],y=f.map((p,P)=>P).sort((p,P)=>f[p].blindedMessage.amount-f[P].blindedMessage.amount),g=[...Array(m.length).fill(!0),...Array(l.length).fill(!1)],q=y.map(p=>f[p]),w=y.map(p=>g[p]);return{payload:{inputs:t,outputs:q.map(p=>p.blindedMessage)},outputData:q,keepVector:w,sortedIndices:y}}async checkProofsStates(e){const t=new TextEncoder,n=e.map(i=>D.hashToCurve(t.encode(i.secret)).toHex(!0)),r=100,o=[];for(let i=0;i<n.length;i+=r){const c=n.slice(i,i+r),{states:a}=await this.mint.check({Ys:c}),h={};a.forEach(d=>{h[d.Y]=d});for(let d=0;d<c.length;d++){const u=h[c[d]];if(!u)throw new Error("Could not find state for proof with Y: "+c[d]);o.push(u)}}return o}async onMintQuoteUpdates(e,t,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_mint_quote",filters:e},t,n);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,t)}}async onMeltQuotePaid(e,t,n){return this.onMeltQuoteUpdates([e],r=>{r.state===F.PAID&&t(r)},n)}async onMintQuotePaid(e,t,n){return this.onMintQuoteUpdates([e],r=>{r.state===R.PAID&&t(r)},n)}async onMeltQuoteUpdates(e,t,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=this.mint.webSocketConnection.createSubscription({kind:"bolt11_melt_quote",filters:e},t,n);return()=>{this.mint.webSocketConnection?.cancelSubscription(r,t)}}async onProofStateUpdates(e,t,n){if(await this.mint.connectWebSocket(),!this.mint.webSocketConnection)throw new Error("failed to establish WebSocket connection.");const r=new TextEncoder,o={};for(let a=0;a<e.length;a++){const h=D.hashToCurve(r.encode(e[a].secret)).toHex(!0);o[h]=e[a]}const i=Object.keys(o),c=this.mint.webSocketConnection.createSubscription({kind:"proof_state",filters:i},a=>{t({...a,proof:o[a.Y]})},n);return()=>{this.mint.webSocketConnection?.cancelSubscription(c,t)}}createOutputData(e,t,n,r,o,i,c){let a;if(r)a=T.createP2PKData({pubkey:r},e,t,o);else if(n||n===0){if(!this._seed)throw new Error("cannot create deterministic messages without seed");a=T.createDeterministicData(e,this._seed,n,t,o)}else i?a=T.createP2PKData(i,e,t,o):c?a=S(e,t.keys).map(d=>c(d,t)):a=T.createRandomData(e,t,o);return a}createBlankOutputs(e,t,n,r){let o=Math.ceil(Math.log2(e))||1;o<0&&(o=0);const i=o?Array(o).fill(1):[];return this.createOutputData(e,t,n,void 0,i,void 0,r)}}exports.CashuMint=b;exports.CashuWallet=mt;exports.CheckStateEnum=Pe;exports.MeltQuoteState=F;exports.MintQuoteState=R;exports.OutputData=T;exports.PaymentRequest=H;exports.PaymentRequestTransportType=Ee;exports.decodePaymentRequest=et;exports.deriveKeysetId=Ye;exports.getDecodedToken=_e;exports.getDecodedTokenBinary=it;exports.getEncodedToken=Ge;exports.getEncodedTokenBinary=ot;exports.getEncodedTokenV4=we;exports.injectWebSocketImpl=ct;exports.setGlobalRequestOptions=ht;
//# sourceMappingURL=cashu-ts.cjs.js.map
